% !TeX spellcheck = pt_PT
\documentclass[a4paper]{report}
\usepackage[portuguese]{babel}
\usepackage{a4wide}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{float}

\setlength{\parskip}{1em}

\title{Sistemas Operativos - Trabalho Prático\\
	\large Grupo 12}
\author{Sofia Santos (A89615)
	\and Ana Filipa Pereira (A89589)
	\and Carolina Santejo (A89500)}
\date{Ano Letivo 2019/2020}

\begin{document}
	\begin{minipage}{0.9\linewidth}
        \centering
		\includegraphics[width=0.4\textwidth]{eng.jpeg}\par\vspace{1cm}
		\href{https://www.uminho.pt/PT}
		{\scshape\LARGE Universidade do Minho} \par
		\vspace{0.6cm}
		\href{https://miei.di.uminho.pt/}
		{\scshape\Large Mestrado Integrado em Engenharia Informática} \par
		\maketitle
		\begin{figure}[H]
			\includegraphics[width=0.32\linewidth]{sofia.jpg}
			\includegraphics[width=0.32\linewidth]{filipa.jpg}
			\includegraphics[width=0.32\linewidth]{santejo.jpg}
		\end{figure}
	\end{minipage}
	
	\tableofcontents
	
	\pagebreak
	
	\chapter{Introdução}
%	
	Este projeto consistiu na criação de um serviço de execução de tarefas, no qual um cliente é capaz de enviar sucessivas tarefas a um servidor, para este as executar.
	Para além de executar tarefas, o servidor permite consultar tarefas em execução ou executadas previamente, consultar o output de cada tarefa, terminar manualmente tarefas, e ainda definir um tempo máximo de execução de cada tarefa ou tempo máximo de comunicação entre pipes.
	
	Numa fase inicial, o maior desafio foi encontrar uma forma de poder encadear um número arbitrário de comandos sucessivos. Mais tarde, também tivemos alguma dificuldade em conseguir obter o estado de um comando, mas acabámos por conseguir superar estes obstáculos.
	
	O cliente e o servidor comunicam através de dois pipes com nome, um envia comandos do cliente para o servidor, e o outro envia o output dos comandos do servidor para o cliente.
	
	\chapter{Comandos disponíveis no servidor}
	\section{Ajuda}
	Este é o comando mais simples, que apenas envia para o cliente uma lista de todos os comandos existentes e de como os deve usar.
	
	\section{Executar}
	Comando central do servidor, permite executar uma ou mais funções encadeadas, enviando para um ficheiro \emph{log} o seu output. Neste comando usamos um ou mais \emph{execvp}, após fazer \textit{parsing} do input, para executar cada função fornecida. Estas funções comunicam entre si através de pipes anónimos. Como não sabemos de quantos pipes um comando irá precisar antes de terminar o \textit{parsing} total do input, por uma questão de eficiência, decidimos dar a cada execução do comando 32 pipes anónimos. Podíamos também ter usado alocação dinâmica de memória, para por um lado evitar usar memória desnecessariamente e por outro permitir a execução de comandos com mais de 32 pipes, mas acreditamos que, para além de que o número atual de pipes que temos não ter um grande peso em termos de memória, 32 já é um número mais que suficiente de pipes para um comando.

	\section{Histórico}
	O servidor contém duas listas, uma que contém todos os comandos executados até ao momento, e outra que contém o estado da execução de cada comando. Este estado pode ser: em execução; concluído; terminado manualmente; terminado por tempo de execução; terminado por inatividade. O comando \emph{historico} envia para o cliente uma lista contendo a informação destas duas listas.
	
	\section{Listar}
	Este comando é uma versão mais simples do comando \emph{historico}, apenas envia para o cliente os comandos do histórico que ainda estejam em execução.
	
	\section{Output}
	Todos os comandos que terminam normalmente escrevem o seu output no ficheiro \emph{log}, e é guardado no ficheiro \emph{log.idx}, associado ao número do comando, a posição do byte final do output no \emph{log}. O comando \emph{output} lê o ficheiro \emph{log} e envia para o cliente o output do comando especificado, começando a ler a partir do fim do output do comando anterior (posição 0 caso seja o primeiro comando) até à posição indicada no ficheiro \emph{log.idx}. Com este sistema apenas temos que armazenar o número do comando e uma posição num ficheiro auxiliar
	
	\section{Terminar}
	Como um comando pode gerar vários processos filhos, é necessário guardar os pids de todos eles, para os podermos terminar. Para isso usamos uma lista, que o comando \emph{terminar} percorre, e para cada pid de um processo filho de um dado comando usa a função \emph{kill} para o terminar, usando o sinal \emph{SIGTERM}.
	
	\section{Tempo de execução}
	Este comando permite-nos definir um tempo máximo durante o qual cada comando pode correr antes de ser terminado à força. O programa guarda numa lista o tempo de execução de cada comando, e a cada segundo verifica, caso o comando ainda esteja em execução, se esse tempo é superior ao tempo máximo de execução. Em caso afirmativo, esse comando é terminado pelo mesmo método do comando \emph{terminar} e o seu estado atualizado. Caso não seja, o tempo de execução desse programa é incrementado em um segundo. Esta sistema funciona usando a função \emph{alarm}, que é chamada uma vez por segundo, e faz essa verificação.
		
	

	\chapter{Conclusão}


\end{document}